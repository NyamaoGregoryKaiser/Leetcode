```typescript
/**
 * @fileoverview Implementation of Breadth-First Search (BFS) for finding
 * the shortest path in an unweighted graph and checking reachability.
 */

import { Graph, NodeId, Edge } from '../data-structures';

/**
 * Finds the shortest path from a source node to a destination node in an unweighted graph using BFS.
 * Returns the path as an array of node IDs or null if no path exists.
 *
 * Time Complexity: O(V + E) - where V is the number of vertices and E is the number of edges.
 *   Each vertex is enqueued/dequeued at most once, and each edge is examined at most once.
 * Space Complexity: O(V) - for the queue, visited set, and parent map.
 *
 * @param {Graph} graph - The graph to traverse.
 * @param {NodeId} startNode - The starting node.
 * @param {NodeId} endNode - The target node.
 * @returns {NodeId[] | null} An array of NodeIds representing the shortest path, or null if no path.
 */
export function shortestPathBFS(graph: Graph, startNode: NodeId, endNode: NodeId): NodeId[] | null {
  // 1. Input Validation: Check if start and end nodes exist in the graph.
  if (!graph.hasNode(startNode) || !graph.hasNode(endNode)) {
    console.warn(`BFS: Start node (${startNode}) or end node (${endNode}) not found in graph.`);
    return null;
  }

  // 2. Trivial Case: If start and end nodes are the same, path is just the start node.
  if (startNode === endNode) {
    return [startNode];
  }

  // Initialize data structures for BFS
  const queue: NodeId[] = [];
  const visited = new Set<NodeId>();
  // `parentMap` stores `child -> parent` to reconstruct the path later.
  const parentMap = new Map<NodeId, NodeId | null>();

  // Start BFS from the `startNode`
  queue.push(startNode);
  visited.add(startNode);
  parentMap.set(startNode, null); // Start node has no parent

  // 3. BFS Traversal
  while (queue.length > 0) {
    const currentNode = queue.shift()!; // Dequeue the first node

    // If we reached the end node, reconstruct and return the path
    if (currentNode === endNode) {
      return reconstructPath(startNode, endNode, parentMap);
    }

    // Explore neighbors of the `currentNode`
    for (const edge of graph.getNeighbors(currentNode)) {
      const neighbor = edge.to;

      // If neighbor has not been visited, mark it, set its parent, and enqueue it
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        parentMap.set(neighbor, currentNode);
        queue.push(neighbor);
      }
    }
  }

  // If the queue becomes empty and `endNode` was not reached, no path exists.
  return null;
}

/**
 * Helper function to reconstruct the path from the start node to the end node
 * using the parent map generated by BFS.
 *
 * @param {NodeId} startNode - The starting node of the path.
 * @param {NodeId} endNode - The ending node of the path.
 * @param {Map<NodeId, NodeId | null>} parentMap - A map storing child -> parent relationships.
 * @returns {NodeId[]} An array of NodeIds representing the path.
 */
function reconstructPath(startNode: NodeId, endNode: NodeId, parentMap: Map<NodeId, NodeId | null>): NodeId[] {
  const path: NodeId[] = [];
  let currentNode: NodeId | null = endNode;

  // Traverse backwards from endNode to startNode using parentMap
  while (currentNode !== null) {
    path.unshift(currentNode); // Add to the beginning to get correct order
    currentNode = parentMap.get(currentNode) || null; // Move to parent
  }

  // The path should start with `startNode`. If it doesn't, it implies an error or an incomplete path.
  // This check ensures we only return a valid path from `startNode` to `endNode`.
  if (path[0] === startNode) {
    return path;
  } else {
    // This case theoretically shouldn't happen if BFS found the endNode and parentMap is correct.
    // It's a safeguard.
    return [];
  }
}

/**
 * Checks if a `targetNode` is reachable from a `startNode` in a graph using BFS.
 * This is a simpler application of BFS, only concerned with reachability, not path.
 *
 * Time Complexity: O(V + E)
 * Space Complexity: O(V)
 *
 * @param {Graph} graph - The graph to traverse.
 * @param {NodeId} startNode - The starting node.
 * @param {NodeId} targetNode - The node to check reachability for.
 * @returns {boolean} True if `targetNode` is reachable from `startNode`, false otherwise.
 */
export function isReachableBFS(graph: Graph, startNode: NodeId, targetNode: NodeId): boolean {
  // Input validation
  if (!graph.hasNode(startNode) || !graph.hasNode(targetNode)) {
    return false;
  }

  if (startNode === targetNode) {
    return true;
  }

  const queue: NodeId[] = [startNode];
  const visited = new Set<NodeId>();
  visited.add(startNode);

  while (queue.length > 0) {
    const currentNode = queue.shift()!;

    if (currentNode === targetNode) {
      return true; // Target found
    }

    for (const edge of graph.getNeighbors(currentNode)) {
      const neighbor = edge.to;
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push(neighbor);
      }
    }
  }

  return false; // Target not reachable
}

/**
 * Counts the number of connected components in an undirected graph.
 *
 * This function iterates through all nodes, and for each unvisited node,
 * it starts a new BFS traversal to find all nodes in its component,
 * incrementing the component count.
 *
 * Time Complexity: O(V + E) - Each node and edge is visited exactly once across all BFS traversals.
 * Space Complexity: O(V) - for the queue and visited set.
 *
 * @param {Graph} graph - The undirected graph.
 * @returns {number} The total number of connected components.
 */
export function countConnectedComponentsBFS(graph: Graph): number {
  if (graph.isDirected()) {
    console.warn("countConnectedComponentsBFS: This function is typically applied to undirected graphs. For directed graphs, consider strongly connected components (SCCs).");
    // For directed graphs, if we simply mean "nodes reachable from each other considering all edges as undirected",
    // then the current logic works by treating the directed graph's adjacency list as undirected.
    // However, if strict SCCs are needed, a different algorithm (e.g., Kosaraju's or Tarjan's) is required.
  }

  const nodes = graph.getNodes();
  if (nodes.length === 0) {
    return 0;
  }

  let componentCount = 0;
  const visited = new Set<NodeId>();

  for (const node of nodes) {
    if (!visited.has(node)) {
      componentCount++;
      const queue: NodeId[] = [node];
      visited.add(node);

      while (queue.length > 0) {
        const currentNode = queue.shift()!;
        for (const edge of graph.getNeighbors(currentNode)) {
          const neighbor = edge.to;
          if (!visited.has(neighbor)) {
            visited.add(neighbor);
            queue.push(neighbor);
          }
        }
      }
    }
  }

  return componentCount;
}
```