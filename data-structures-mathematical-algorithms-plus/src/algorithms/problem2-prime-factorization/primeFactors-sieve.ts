/**
 * problem2-prime-factorization/primeFactors-sieve.ts
 *
 * Implements prime factorization using a precomputed Smallest Prime Factor (SPF)
 * array generated by a Sieve of Eratosthenes. This approach is highly efficient
 * for finding prime factors of multiple numbers within a certain range, or for a single
 * number if the range is small enough for precomputation.
 *
 * Precomputation (Sieve):
 * Time Complexity: O(MAX_N * log(log MAX_N)) for building the SPF array.
 * Space Complexity: O(MAX_N) for storing the SPF array.
 *
 * Factorization Query:
 * Time Complexity: O(log N) per query.
 *   Because at each step, `n` is divided by its smallest prime factor, `n` reduces
 *   multiplicatively. The number of divisions is at most `log N` (e.g., for N = 2^k, k divisions).
 * Space Complexity: O(log N) to store the factors for a single query.
 */

// Define a maximum limit for the sieve. This can be adjusted based on requirements.
// For interview purposes, MAX_N could be around 10^5 to 10^7.
const MAX_SIEVE_LIMIT = 1_000_000; // 1 million
const spf: number[] = new Array(MAX_SIEVE_LIMIT + 1).fill(0); // Smallest Prime Factor array

// Flag to ensure sieve is initialized only once.
let isSieveInitialized = false;

/**
 * Initializes the Smallest Prime Factor (SPF) array using a modified Sieve of Eratosthenes.
 * `spf[i]` will store the smallest prime factor of `i`.
 * This function should be called once before performing factorizations.
 */
function sieve(): void {
    if (isSieveInitialized) {
        return; // Sieve already initialized
    }

    // Initialize spf[i] = i for all i.
    // This means initially, every number is considered its own smallest prime factor.
    for (let i = 2; i <= MAX_SIEVE_LIMIT; i++) {
        spf[i] = i;
    }

    // Mark multiples of 2
    for (let i = 4; i <= MAX_SIEVE_LIMIT; i += 2) {
        spf[i] = 2;
    }

    // Iterate for odd numbers starting from 3
    // For each prime number `p`, mark `p` as the SPF for all its multiples `p*p`, `p*p + p`, ...
    // but only if they haven't been marked by a smaller prime factor already.
    for (let i = 3; i * i <= MAX_SIEVE_LIMIT; i += 2) {
        // If i is its own smallest prime factor, then i is prime.
        if (spf[i] === i) {
            // Mark all multiples of i (starting from i*i)
            for (let j = i * i; j <= MAX_SIEVE_LIMIT; j += i) {
                // Only update spf[j] if it hasn't been set by a smaller prime yet.
                if (spf[j] === j) {
                    spf[j] = i;
                }
            }
        }
    }

    isSieveInitialized = true;
}

/**
 * Finds the prime factors of a positive integer `n` using a precomputed SPF array.
 *
 * @param n The positive integer to factorize. Must be within the `MAX_SIEVE_LIMIT`.
 * @returns An array of prime factors of `n`. Returns an empty array for `n = 1`.
 * @throws Error if `n` is out of bounds or not a positive integer.
 */
export function primeFactorsSieve(n: number): number[] {
    sieve(); // Ensure the sieve is initialized

    if (n < 1 || !Number.isInteger(n)) {
        throw new Error("Input must be a positive integer.");
    }
    if (n === 1) {
        return []; // 1 has no prime factors
    }
    if (n > MAX_SIEVE_LIMIT) {
        // This method is only efficient up to MAX_SIEVE_LIMIT.
        // For larger numbers, trial division or Pollard's rho might be needed.
        throw new Error(`Input ${n} exceeds MAX_SIEVE_LIMIT (${MAX_SIEVE_LIMIT}). Use trial division for larger numbers.`);
    }

    const factors: number[] = [];
    let currentN = n;

    // Repeatedly divide currentN by its smallest prime factor until currentN becomes 1.
    while (currentN !== 1) {
        const factor = spf[currentN];
        factors.push(factor);
        currentN /= factor;
    }

    return factors;
}

/**
 * Resets the sieve initialization flag. Useful for testing or re-initializing with a different limit
 * if this function were extended. For this problem, it's mostly for test hygiene.
 */
export function resetSieveForTesting(): void {
    isSieveInitialized = false;
    // Optionally clear spf array if memory is a concern or limit changes.
    // For now, it's fine as the limit is fixed.
    spf.fill(0);
}

// Export MAX_SIEVE_LIMIT for external reference, e.g., in tests.
export { MAX_SIEVE_LIMIT };